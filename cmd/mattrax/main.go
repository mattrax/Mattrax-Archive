//go:generate go run ../../scripts/gqlgen.go
//go:generate yarn -s --prod --non-interactive --cwd ./../../web/
//go:generate yarn -s --prod --non-interactive --cwd ./../../web/ build
//go:generate go run -tags=dev ../../scripts/vfsgen.go
//go:generate mv assets_vfsdata.go assets/assets_vfsdata.go
//go:generate rm -rf ./../../web/build
package main

import (
	"flag"

	"github.com/kataras/muxie"
	"github.com/mattrax/Mattrax/cmd/mattrax/assets"
	"github.com/mattrax/Mattrax/internal/certstore"
	"github.com/mattrax/Mattrax/internal/config"
	appleendpoints "github.com/mattrax/Mattrax/platform/apple/endpoints"
	applepostgres "github.com/mattrax/Mattrax/platform/apple/storage/postgres"
	"github.com/oscartbeaumont/go-utils/http"
	"github.com/oscartbeaumont/go-utils/log"
	"github.com/rs/zerolog/log"
)

// TODO: Logging System To From The Admin Interface An Admin Can View All Failures For Debugging
// TODO: Use Fatal Instead Of Boiling Up Errors So Line Numbers Work - Is This Idiomatic

var (
	flgDomain      = flag.String("domain", "", "the domain name of your server. eg. 'example.com'")
	flgPort        = flag.Int("port", 9000, "the port for the webserver, please note when using Let's Encrypt this is ignored. eg. 8000")
	flgLetsencrypt = flag.Bool("letsencrypt", false, "enable automatic https certificates using Let's Encrypt and agree to thier terms of service. It creates a http webserver on port 80 which redirects (and does https activation) for the https server running on port 443. These ports can't be changed.")
	flgCertCache   = flag.String("cert-cache", "certs", "the directory to cache your https certificates generated by Let's Encrypt. eg. '/var/certs'")
	flgEmail       = flag.String("email", "", "the email address for Let's Encrypt renewal notices. eg. 'webmaster@example.com'")
	flgTLSCert     = flag.String("tls-cert", "", "path to a valid TLS certificate for the webserver. eg. '/var/certs/cert.crt'")
	flgTLSKey      = flag.String("tls-key", "", "path to a valid TLS private key for the webserver. eg. '/var/certs/cert.key'")
	// TEMP: flgDatabaseFile = flag.String("database-file", "{{APPNAME}}.db", "the path on disk for the database file. Please be sure to backup this file! eg. '/var/my_database.db'")
	flgLogFile     = flag.String("log-file", "", "the path on disk for the log file to be stored. If left blank no log file is stored. eg. '/var/log/log.txt'")
	flgJSONConsole = flag.Bool("json-console", false, "sets the format of the console logger to json")
	flConfigPath   = flag.String("config-path", "/var/mattrax", "the path on disk where Mattrax stores its data. This includes configurations and caches.")
	flgDebug       = flag.Bool("debug", false, "enabled extra verbose logging and less security checks. Designed to make development easier and should only be used by developers")
	flgVersion     = flag.Bool("version", false, "shows the version and build details of the binary. Usefull to include in bug reports")
)

func main() {
	flag.Parse()
	if *flgVersion {
		displayVersion()
		return
	}
	if err := logutils.Setup(*flgJSONConsole, *flgLogFile, *flgDebug); err != nil {
		log.Fatal().Err(err).Msg("Error setting up the logging")
	}
	if *flgDebug {
		log.Debug().Msg("WARNING: You started the server in debug mode. This should ONLY be done for development and this will possibly make your server less secure!")
		assets.ServeFromFileSystem()
	}
	if !*flgDebug && *flgDomain == "" {
		log.Info().Msg("WARNING: Your server is running in production mode and you did not set a domain. This is not recommended!")
	}
	log.Info().Str("creator", "Oscar Beaumont").Msg("Starting Mattrax...")
	mux := muxie.NewMux()
	mux.PathCorrection = true
	routes(mux)

	config := config.Config{
		PublicURL:  "https://mdm.otbeaumont.me",
		TenantName: "Acme School Inc",
	}

	certStore, err := certstore.New("./certs")
	if err != nil {
		log.Fatal().Err(err).Msg("Error initialising the certificate store")
	}

	// TEMP This is the old store
	// certificateStore, err := certificates.NewStore("./certs/apple.crt", "./certs/apple.key")
	// if err != nil {
	// 	log.Fatal().Err(err).Msg("Error initialising the certificate store")
	// }

	// TODO: is Having two DB Connections One for Apple and one for Microsoft bad?

	appleStorage, err := applepostgres.New("localhost", "oscar.beaumont", "", "mattraxy", "disable") // TODO: Load From Config
	if err != nil {
		log.Fatal().Err(err).Msg("Error initialising the certificate store")
	}
	appleEndpoints := appleendpoints.New(config, certStore, appleStorage) // TODO: Remove config + certificateStore (Replace with appleStorage) from here
	appleEndpoints.MountEndpoints(mux)

	if err := httputils.ListenAndServe(*flgDomain, *flgPort, *flgLetsencrypt, *flgCertCache, *flgEmail, *flgTLSCert, *flgTLSKey, mux); err != nil {
		log.Fatal().Err(err).Msg("Error starting/stoppping the web server")
	}
}
