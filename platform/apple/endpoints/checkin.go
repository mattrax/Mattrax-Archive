package endpoints

import (
	"database/sql"
	"fmt"
	"net/http"
	"time"

	"github.com/groob/plist"
	"github.com/mattrax/Mattrax/platform/apple/endpoints/structs"
	"github.com/mattrax/Mattrax/platform/apple/storage"
	"github.com/rs/zerolog/log"
)

// TODO: Remoev all log.Fatal() or panic()

func (svc *Service) checkinHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var cmd structs.CheckinCommand
		if err := plist.NewXMLDecoder(r.Body).Decode(&cmd); err != nil {
			log.Debug().Str("protocol", "apple/checkin").Msg("FAILED Checkin. Invalid Request Body.")
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		// TODO: Maybe Make This a middleware
		device, fetchErr := svc.Storage.FindDevice(cmd.UDID)
		if fetchErr == sql.ErrNoRows {
			// TODO: Check For MDM Signature Header
		} else if fetchErr != nil {
			log.Fatal().Err(fetchErr).Msg("Error creating the device") // TODO: Clean Error Message
		}

		switch cmd.MessageType {
		case "Authenticate":
			if cmd.Topic == "" || cmd.UDID == "" || cmd.OSVersion == "" || cmd.BuildVersion == "" || cmd.ProductName == "" || cmd.SerialNumber == "" {
				log.Debug().Str("protocol", "apple/checkin").Str("MessageType", cmd.MessageType).Interface("Command", cmd).Msg("FAILED Checkin. Invalid Fields.") //TODO: Dump Fields
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			if fetchErr != sql.ErrNoRows { // If Device Exists
				log.Debug().Str("protocol", "apple/checkin").Str("MessageType", cmd.MessageType).Msg("FAILED Checkin. Device Already Exists.")
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			// TODO: Verify The Profile Was Generated By Mattrax - Add Who Created It Is Added To The Database Entry
			// TODO: Deal With Duplicates or Half Enrolled State
			// TODO: Delete Half Enrolled Devices After 1 hour

			err := svc.Storage.CreateDevice(storage.Device{
				UUID:         cmd.UDID,
				State:        0,
				Topic:        cmd.Topic,
				OSVersion:    cmd.OSVersion,
				BuildVersion: cmd.BuildVersion,
				ProductName:  cmd.ProductName,
				SerialNumber: cmd.SerialNumber,
				IMEI:         cmd.IMEI,
				MEID:         cmd.MEID,
				DeviceName:   cmd.DeviceName,
				Challenge:    cmd.Challenge,
				Model:        cmd.Model,
				ModelName:    cmd.ModelName,
				CreatedBy:    "00000000-0000-0000-0000-000000000000", // TEMP: Placeholder until Users exist and it is coded
				CreatedAt:    time.Now(),
			})
			if err != nil {
				log.Fatal().Err(err).Msg("Error creating the device") // TODO: Clean Error Message
			}

		case "TokenUpdate": // TODO: Gracefull Recover From DEP AwaitingConfig - Until I Can get access to DEP to implemented it
			// if cmd.Token == nil || cmd.PushMagic == "" || cmd.UnlockToken == nil {
			// 	log.Debug().Str("protocol", "apple/checkin").Str("MessageType", cmd.MessageType).Interface("Command", cmd).Msg("FAILED Checkin. Invalid Fields.") //TODO: Dump Fields
			// 	w.WriteHeader(http.StatusUnauthorized)
			// 	return
			// } // TODO: Fix

			if fetchErr == sql.ErrNoRows { // If Device Exists
				log.Debug().Str("protocol", "apple/checkin").Str("MessageType", cmd.MessageType).Msg("FAILED Checkin. Device Isn't Enrolled.")
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			// TODO: Check The Device is already enrolled

			fmt.Println(cmd.UnlockToken)
			err := svc.Storage.UpdateTokens(device.UUID, cmd.Token, cmd.PushMagic, cmd.UnlockToken)
			if err != nil {
				log.Fatal().Err(err).Msg("Error updating devices tokens") // TODO: Clean Error Message
			}

		case "CheckOut":
			//panic("not implemented (CheckOut)") // TEMP
		default:
			log.Debug().Str("protocol", "apple/checkin").Str("MessageType", cmd.MessageType).Msg("FAILED Checkin. Invalid MessageType.")
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
	}
}

func Authenticate(cmd structs.CheckinCommand, w http.ResponseWriter) {

	// TODO: Convert The Req to A Device Struct
	// TODO: Send That Struct To The Store
	log.Info().Interface("checkin", cmd).Msg("A Device Checked In") // TEMP

	// TODO: REMEBER NOT ENROLLED UNTIL TokenUpdate

	w.WriteHeader(http.StatusOK)
}
